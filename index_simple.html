<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="–°–æ–∑–¥–∞–≤–∞–π—Ç–µ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –ø–æ—Ä—Ç—Ä–µ—Ç—ã –≤ —Å—Ç–∏–ª–µ –†–µ—á–∏ –ü–æ—Å–ø–æ–ª–∏—Ç–æ–π –∏ –í–µ–ª–∏–∫–æ–≥–æ –ö–Ω—è–∂–µ—Å—Ç–≤–∞ –õ–∏—Ç–æ–≤—Å–∫–æ–≥–æ">
    <title>‚öúÔ∏è –ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–π –ø–æ—Ä—Ç—Ä–µ—Ç</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#B8860B">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="–ò—Å—Ç–æ—Ä–ü–æ—Ä—Ç—Ä–µ—Ç">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&family=Cinzel+Decorative:wght@400;700&display=swap" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: radial-gradient(ellipse at top left, rgba(101, 67, 33, 0.08) 0%, transparent 50%), radial-gradient(ellipse at bottom right, rgba(139, 69, 19, 0.12) 0%, transparent 60%), linear-gradient(135deg, #050302 0%, #0a0805 25%, #1a0f0a 50%, #0a0805 75%, #050302 100%);
            color: #F8F0E6;
            font-family: 'Cinzel', serif;
            min-height: 100vh;
            padding: 15px;
            overflow-x: hidden;
            position: relative;
        }
        
        .container {
            max-width: 450px;
            margin: 0 auto;
            background: linear-gradient(145deg, rgba(15, 10, 8, 0.95) 0%, rgba(25, 18, 12, 0.95) 100%), radial-gradient(circle at center, rgba(139, 69, 19, 0.1) 0%, transparent 70%);
            border-radius: 20px;
            padding: 25px;
            border: 4px solid #DAA520;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.9), inset 0 2px 0 rgba(255, 215, 0, 0.4), 0 0 40px rgba(218, 165, 32, 0.5), inset 0 0 30px rgba(101, 67, 33, 0.2);
            position: relative;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            font-family: 'Cinzel Decorative', serif;
            font-size: 28px;
            font-weight: 700;
            color: #FFE55C;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 1), 1px 1px 0 rgba(139, 69, 19, 0.8), -1px -1px 0 rgba(139, 69, 19, 0.8), 0 0 15px rgba(255, 215, 0, 0.6);
            margin-bottom: 8px;
            filter: drop-shadow(0 0 8px rgba(255, 229, 92, 0.4));
            text-align: center;
        }
        
        .upload-area {
            border: 3px dashed #DAA520;
            border-radius: 15px;
            padding: 35px 20px;
            text-align: center;
            margin: 20px 0;
            transition: all 0.4s ease;
            cursor: pointer;
            background: linear-gradient(135deg, rgba(10, 8, 5, 0.8) 0%, rgba(20, 15, 10, 0.8) 100%);
            position: relative;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 215, 0, 0.2);
        }
        
        .btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 0;
            font-family: 'Cinzel', serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            background: linear-gradient(145deg, #DAA520, #FFD700);
            color: #0a0805;
            box-shadow: 0 10px 20px rgba(184, 134, 11, 0.5), inset 0 2px 0 rgba(255, 255, 255, 0.4), 0 0 15px rgba(255, 215, 0, 0.3);
            border: 3px solid #FFE55C;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            font-weight: 700;
        }
        
        .file-input {
            display: none;
        }
        
        .result-area {
            text-align: center;
            margin: 20px 0;
            display: none;
        }
        
        .result-canvas {
            max-width: 100%;
            border-radius: 10px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.6), 0 0 20px rgba(255, 215, 0, 0.3);
            border: 4px solid #B8860B;
        }
        
        .status {
            color: #F8F0E6;
            margin: 15px 0;
            font-style: italic;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 1), 1px 1px 0 rgba(101, 67, 33, 0.6);
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>‚öúÔ∏è –ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–π –ø–æ—Ä—Ç—Ä–µ—Ç</h1>
        <p style="text-align: center; margin-bottom: 20px; color: #F0E6DA;">–£–º–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —á–µ–ª–æ–≤–µ–∫–∞</p>

        <div class="upload-area" onclick="document.getElementById('fileInput').click()">
            <span style="font-size: 40px; margin-bottom: 12px; display: block;">üñºÔ∏è</span>
            <p><strong>–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ç–æ —Å —á–µ–ª–æ–≤–µ–∫–æ–º</strong></p>
            <p style="opacity: 0.8; margin-top: 5px; font-style: italic;">–†–∞–±–æ—Ç–∞–µ—Ç —Å –ª—é–±—ã–º —Ñ–æ–Ω–æ–º!</p>
        </div>

        <input type="file" id="fileInput" class="file-input" accept="image/*">
        <button id="processBtn" class="btn" disabled>üé® –°–æ–∑–¥–∞—Ç—å –ø–æ—Ä—Ç—Ä–µ—Ç</button>

        <div id="status" class="status"></div>

        <div id="resultArea" class="result-area">
            <canvas id="resultCanvas" class="result-canvas"></canvas>
            <br><br>
            <button onclick="location.reload()" class="btn">üîÑ –ù–æ–≤—ã–π –ø–æ—Ä—Ç—Ä–µ—Ç</button>
        </div>
    </div>

    <script>
        let uploadedImage = null;

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                uploadedImage = new Image();
                uploadedImage.onload = function() {
                    document.querySelector('.upload-area').innerHTML = `
                        <span style="font-size: 40px; margin-bottom: 12px; display: block;">‚úÖ</span>
                        <p><strong>–§–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ!</strong></p>
                        <p style="opacity: 0.8;">${file.name}</p>
                    `;
                    document.getElementById('processBtn').disabled = false;
                };
                uploadedImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ—Ä—Ç—Ä–µ—Ç–∞
        document.getElementById('processBtn').addEventListener('click', async function() {
            if (!uploadedImage) return;

            const statusEl = document.getElementById('status');
            const resultArea = document.getElementById('resultArea');
            const canvas = document.getElementById('resultCanvas');
            const ctx = canvas.getContext('2d');

            // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ canvas
            canvas.width = 400;
            canvas.height = 600;

            try {
                statusEl.textContent = 'üß† –ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...';
                await new Promise(resolve => setTimeout(resolve, 500));

                statusEl.textContent = 'üéØ –£–º–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —á–µ–ª–æ–≤–µ–∫–∞...';

                // –°–æ–∑–¥–∞–Ω–∏–µ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–æ–π –º–∞—Å–∫–∏
                const segmentationResult = await segmentPersonIntelligently(uploadedImage);

                statusEl.textContent = 'üé® –°–æ–∑–¥–∞–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–æ–≥–æ —Ñ–æ–Ω–∞...';

                // –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–æ–Ω–∞
                const backgroundCanvas = createHistoricalBackground();

                statusEl.textContent = '‚ú® –§–∏–Ω–∞–ª—å–Ω–∞—è –∫–æ–º–ø–æ–∑–∏—Ü–∏—è...';

                // –ö–æ–º–ø–æ–∑–∏—Ü–∏—è
                await composePortrait(ctx, canvas, uploadedImage, segmentationResult, backgroundCanvas);

                statusEl.textContent = 'üéâ –ü–æ—Ä—Ç—Ä–µ—Ç –≥–æ—Ç–æ–≤!';
                resultArea.style.display = 'block';

            } catch (error) {
                console.error('–û—à–∏–±–∫–∞:', error);
                statusEl.textContent = '‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ—Ä—Ç—Ä–µ—Ç–∞';
            }
        });

        // –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞—è —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è
        async function segmentPersonIntelligently(imageElement) {
            console.log('üß† –ù–∞—á–∏–Ω–∞–µ–º –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—É—é —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—é...');

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = imageElement.width;
            tempCanvas.height = imageElement.height;
            tempCtx.drawImage(imageElement, 0, 0);

            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;

            // –°–æ–∑–¥–∞–Ω–∏–µ —É–º–Ω–æ–π –º–∞—Å–∫–∏
            const mask = createSmartMask(data, tempCanvas.width, tempCanvas.height);

            return {
                mask,
                width: tempCanvas.width,
                height: tempCanvas.height
            };
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —É–º–Ω–æ–π –º–∞—Å–∫–∏
        function createSmartMask(imageData, width, height) {
            const mask = new Uint8ClampedArray(width * height);

            // –ê–Ω–∞–ª–∏–∑ –∫—Ä–∞–µ–≤ (–≤–µ—Ä–æ—è—Ç–Ω—ã–π —Ñ–æ–Ω)
            const edgeColors = analyzeEdgeColors(imageData, width, height);

            // –ê–Ω–∞–ª–∏–∑ –∫–∞–∂–¥–æ–≥–æ –ø–∏–∫—Å–µ–ª—è
            for (let i = 0; i < imageData.length; i += 4) {
                const pixelIndex = Math.floor(i / 4);
                const r = imageData[i];
                const g = imageData[i + 1];
                const b = imageData[i + 2];
                const alpha = imageData[i + 3];

                if (alpha < 50) {
                    mask[pixelIndex] = 0; // –ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π = —Ñ–æ–Ω
                    continue;
                }

                // –ü—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —á–µ–ª–æ–≤–µ–∫–∞ vs —Ñ–æ–Ω
                const isSkinTone = checkSkinTone(r, g, b);
                const isEdgeColor = checkEdgeColor(r, g, b, edgeColors);
                const centerDistance = getCenterDistance(pixelIndex, width, height);
                const uniformity = checkUniformity(imageData, pixelIndex, width, height, r, g, b);

                // –õ–æ–≥–∏–∫–∞ –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏—è
                let humanProbability = 0;

                if (isSkinTone) humanProbability += 0.4;
                if (!isEdgeColor) humanProbability += 0.2;
                if (centerDistance < 0.6) humanProbability += 0.3;
                if (uniformity < 0.7) humanProbability += 0.1;

                mask[pixelIndex] = humanProbability > 0.5 ? 255 : 0;
            }

            // –°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ –º–∞—Å–∫–∏
            return smoothMask(mask, width, height);
        }

        // –ê–Ω–∞–ª–∏–∑ —Ü–≤–µ—Ç–æ–≤ –Ω–∞ –∫—Ä–∞—è—Ö
        function analyzeEdgeColors(imageData, width, height) {
            const edgeColors = [];
            const edgeWidth = Math.min(width, height) * 0.1;

            for (let i = 0; i < imageData.length; i += 4) {
                const pixelIndex = Math.floor(i / 4);
                const x = pixelIndex % width;
                const y = Math.floor(pixelIndex / width);

                if (x < edgeWidth || x > width - edgeWidth ||
                    y < edgeWidth || y > height - edgeWidth) {
                    edgeColors.push({
                        r: imageData[i],
                        g: imageData[i + 1],
                        b: imageData[i + 2]
                    });
                }
            }

            return edgeColors;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ü–≤–µ—Ç –∫–æ–∂–∏
        function checkSkinTone(r, g, b) {
            // –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –¥–∏–∞–ø–∞–∑–æ–Ω—ã —Ü–≤–µ—Ç–æ–≤ –∫–æ–∂–∏
            const skinRanges = [{
                    r: [180, 255],
                    g: [140, 220],
                    b: [100, 180]
                }, // –°–≤–µ—Ç–ª–∞—è
                {
                    r: [120, 200],
                    g: [80, 150],
                    b: [50, 120]
                }, // –°—Ä–µ–¥–Ω—è—è
                {
                    r: [60, 140],
                    g: [40, 100],
                    b: [20, 80]
                } // –¢–µ–º–Ω–∞—è
            ];

            return skinRanges.some(range =>
                r >= range.r[0] && r <= range.r[1] &&
                g >= range.g[0] && g <= range.g[1] &&
                b >= range.b[0] && b <= range.b[1]
            );
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ü–≤–µ—Ç –∫—Ä–∞—è (—Ñ–æ–Ω)
        function checkEdgeColor(r, g, b, edgeColors) {
            return edgeColors.some(edge => {
                const distance = Math.sqrt(
                    Math.pow(r - edge.r, 2) +
                    Math.pow(g - edge.g, 2) +
                    Math.pow(b - edge.b, 2)
                );
                return distance < 40;
            });
        }

        // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞
        function getCenterDistance(pixelIndex, width, height) {
            const x = pixelIndex % width;
            const y = Math.floor(pixelIndex / width);
            const centerX = width / 2;
            const centerY = height / 2;

            const distance = Math.sqrt(
                Math.pow(x - centerX, 2) +
                Math.pow(y - centerY, 2)
            );

            const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);
            return distance / maxDistance;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–¥–Ω–æ—Ä–æ–¥–Ω–æ—Å—Ç–∏
        function checkUniformity(imageData, pixelIndex, width, height, r, g, b) {
            const x = pixelIndex % width;
            const y = Math.floor(pixelIndex / width);
            const radius = 3;
            let similarPixels = 0;
            let totalPixels = 0;

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        const nIndex = (ny * width + nx) * 4;
                        const nr = imageData[nIndex];
                        const ng = imageData[nIndex + 1];
                        const nb = imageData[nIndex + 2];

                        const distance = Math.sqrt(
                            Math.pow(r - nr, 2) +
                            Math.pow(g - ng, 2) +
                            Math.pow(b - nb, 2)
                        );

                        if (distance < 25) similarPixels++;
                        totalPixels++;
                    }
                }
            }

            return similarPixels / totalPixels;
        }

        // –°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ –º–∞—Å–∫–∏
        function smoothMask(mask, width, height) {
            const smoothed = new Uint8ClampedArray(mask.length);
            const radius = 2;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let sum = 0;
                    let count = 0;

                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;

                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                sum += mask[ny * width + nx];
                                count++;
                            }
                        }
                    }

                    smoothed[y * width + x] = sum / count;
                }
            }

            return smoothed;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–æ–≥–æ —Ñ–æ–Ω–∞
        function createHistoricalBackground() {
            const bgCanvas = document.createElement('canvas');
            const bgCtx = bgCanvas.getContext('2d');
            bgCanvas.width = 400;
            bgCanvas.height = 600;

            // –ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–π –≥—Ä–∞–¥–∏–µ–Ω—Ç
            const gradient = bgCtx.createLinearGradient(0, 0, bgCanvas.width, bgCanvas.height);
            gradient.addColorStop(0, '#4a3d2f');
            gradient.addColorStop(0.5, '#6b5b47');
            gradient.addColorStop(1, '#8b7355');

            bgCtx.fillStyle = gradient;
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

            // –¢–µ–∫—Å—Ç—É—Ä–∞ —Å—Ç–∞—Ä–∏–Ω—ã
            bgCtx.globalAlpha = 0.15;
            for (let i = 0; i < 300; i++) {
                const brightness = Math.random() * 100;
                bgCtx.fillStyle = `rgba(${brightness}, ${brightness * 0.8}, ${brightness * 0.6}, 0.1)`;
                bgCtx.fillRect(Math.random() * bgCanvas.width, Math.random() * bgCanvas.height, 2, 2);
            }
            bgCtx.globalAlpha = 1;

            return bgCanvas;
        }

        // –ö–æ–º–ø–æ–∑–∏—Ü–∏—è –ø–æ—Ä—Ç—Ä–µ—Ç–∞
        async function composePortrait(ctx, canvas, userImage, segmentationResult, backgroundCanvas) {
            // –†–∏—Å—É–µ–º —Ñ–æ–Ω
            ctx.drawImage(backgroundCanvas, 0, 0);

            // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π canvas –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = 300;
            tempCanvas.height = 400;

            // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            const scale = Math.min(tempCanvas.width / userImage.width, tempCanvas.height / userImage.height);
            const scaledWidth = userImage.width * scale;
            const scaledHeight = userImage.height * scale;
            const offsetX = (tempCanvas.width - scaledWidth) / 2;
            const offsetY = (tempCanvas.height - scaledHeight) / 2;

            tempCtx.drawImage(userImage, offsetX, offsetY, scaledWidth, scaledHeight);

            // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;

            // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –º–∞—Å–∫—É
            const mask = scaleArray(segmentationResult.mask,
                segmentationResult.width, segmentationResult.height,
                tempCanvas.width, tempCanvas.height);

            // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∞—Å–∫—É –∏ —Ñ–∏–ª—å—Ç—Ä—ã
            for (let i = 0; i < data.length; i += 4) {
                const pixelIndex = Math.floor(i / 4);
                const maskValue = mask[pixelIndex] / 255;

                if (maskValue > 0.1) { // –ï—Å–ª–∏ —ç—Ç–æ —á–µ–ª–æ–≤–µ–∫
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–µ–ø–∏—é
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                    data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                    data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                } else {
                    // –î–µ–ª–∞–µ–º —Ñ–æ–Ω –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º
                    data[i + 3] = 0;
                }
            }

            tempCtx.putImageData(imageData, 0, 0);

            // –†–∏—Å—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–∞ –ø–æ—Ä—Ç—Ä–µ—Ç–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏
            const portraitX = 50;
            const portraitY = 80;
            const portraitWidth = 300;
            const portraitHeight = 400;

            ctx.drawImage(tempCanvas, portraitX, portraitY, portraitWidth, portraitHeight);

            // –î–æ–±–∞–≤–ª—è–µ–º –¥–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—É—é —Ä–∞–º–∫—É
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 6;
            ctx.strokeRect(portraitX - 3, portraitY - 3, portraitWidth + 6, portraitHeight + 6);

            // –ó–∞–≥–æ–ª–æ–≤–æ–∫
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 24px "Cinzel Decorative", serif';
            ctx.textAlign = 'center';
            ctx.fillText('–ö—Ä–µ—Å—Ç—å—è–Ω–∏–Ω', canvas.width / 2, 50);

            // –ü–æ–¥–ø–∏—Å—å
            ctx.font = '16px "Cinzel", serif';
            ctx.fillStyle = '#F4E4BC';
            ctx.fillText('XVI-XVII –≤–µ–∫', canvas.width / 2, 520);
            ctx.fillText('–†–µ—á—å –ü–æ—Å–ø–æ–ª–∏—Ç–∞—è', canvas.width / 2, 545);
        }

        // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –º–∞—Å—Å–∏–≤–∞
        function scaleArray(sourceArray, sourceWidth, sourceHeight, targetWidth, targetHeight) {
            const targetArray = new Uint8ClampedArray(targetWidth * targetHeight);

            for (let y = 0; y < targetHeight; y++) {
                for (let x = 0; x < targetWidth; x++) {
                    const sourceX = Math.floor(x * sourceWidth / targetWidth);
                    const sourceY = Math.floor(y * sourceHeight / targetHeight);
                    const sourceIndex = sourceY * sourceWidth + sourceX;
                    const targetIndex = y * targetWidth + x;

                    targetArray[targetIndex] = sourceArray[sourceIndex] || 0;
                }
            }

            return targetArray;
        }

        console.log('‚öúÔ∏è –ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–π –ø–æ—Ä—Ç—Ä–µ—Ç v6.0 - –ü—Ä–æ—Å—Ç–æ–π –∏ –Ω–∞–¥–µ–∂–Ω—ã–π!');
        console.log('üß† –£–º–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏–∏ –±–µ–∑ –≤–Ω–µ—à–Ω–∏—Ö –±–∏–±–ª–∏–æ—Ç–µ–∫');
        console.log('üéØ –†–∞–±–æ—Ç–∞–µ—Ç —Å –ª—é–±—ã–º–∏ —Ñ–æ–Ω–∞–º–∏');
        console.log('‚ö° –ë—ã—Å—Ç—Ä–æ –∏ —Å—Ç–∞–±–∏–ª—å–Ω–æ');
    </script>
</body>

</html>